Добавление нового токенизера на примере произольного токенизера.
Документация для улучшения понимания работы парсера.

для примера добавим следующую грамматическую конструкцию:
specq QUOTE_TYPE NAME;
будет использоваться для обозначения выделенных фрагментов.
ескейпинг внутри в отличие от кавычек поддерживаться не будет.
в остальном - расширения функциональности кавычек.
распознает тексты вида
QUOTE_TYPE
текст без QUOTE_TYPE (в отличие от quoted нельзя экранировать)
QUOTE_TYPE

1. Необходимо задать токенизер в stdt.c
Достаточно тривиально.
- создаем функцию stdt_lexer_specq - для регистрации нашего арсера
- parse_lexer_quoted_string для непосредственного парсинга
- создаем тип stdt_lexer_specq (в нем будет указываться delimiter -
QUOTE_TYPE);

тип возвращаемого парсером дерева бере от quoted.
те же используем и коллбеки
в функции регистрации добавляем параметр - delimiter, через него будет
указываться разделяющий символ

алгоритм реализации будет терминальным говном. как реализовать КМП в
рамках моей структуры - не понятно совсем. по моему мне удалось создать
экспоненциальный по сложности алгоритм поиска в строке (вместо M*N
банальным брутфорсом или O(N) КМП)

2. вторым шагом необходимо добавить его в gen_atree.c
В этом файле задается парсер для файлов гармматики. Через эти грамматики
становится возможным использование токенизера.
Описание нашего парсера будет таково:
linear specq := "specq" delimiter name;
quoted delimiter;
tstring name;
- добавим функцию register_specq для регистрации парсера во всех
парсерах интерпретируемых pgen в соответствии с этйо схемой.
Теперь все файлы с описанием нового токена будут парситься. Но нам еще
нужно добавить экзекутор для интерпретируемых парсеров, который бы при
получении этого описания регистрировал бы наш новый парсер.
- добавим функцию cb_specq

Теперь при исполнении парсера, если в файле описании грамматики
встречается описание нового парсера он будет зарегисрирован этой
функцией. Функция описанная на шаге 1 вызываетя реально только из этого
места. cb_specq. Но кроме того из этой функции регистрируется некоторый
коллбек, вызываемый для всех деревьев разбора построенных нашим парсером
Этот коллбек служит хаком для превращения дерева разбора ptemplate в
более продвинутое атрибутное дерево.

3. третий шаг - добавление преобразователя в ptpl2atree.c
В случае нашего парсера это не требуется. Дерево разбора нашего парсера
совпадает с деревом разбора QuotedString и простой String.Соответственно
конвертер этих деревьев cb_exec_tstring будет достаточне. И этот файл мы
не трогаем. Теерь остается протестировать наш парсер.

Вообще получается довольно глубокая система коллбеков.
1. напрямую вызывается функция register_specq
2. из register_specq регистрируется cb_specq
3. из cb_specq регистрируется stdt_lexer_specq и коллбек cb_exec_tstring
4. из stdt_lexer_specq регистрируется parse_lexer_specq, а также
вспомогательные коллбеки для помощи парсера

и самый главный момент:

	gen_simple_select_cpt_next_select(lc, "pgen.specq");
добавляем наш токен в список типов грамматик
